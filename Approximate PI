import math #This module is used for the fsum function.
pi=[3] #we create a pi list using 3 as our first term.
denominator=[2,3,4] #we then create our denominator list with the three digits of the second term.
#here we ask the user to input the number of pi approximations they want. This will be used as the max value for all the loops.

num_approx=int(input("Pleasure insert the number of approximations of pi you want: "))

"""the purpose of the loop below is to fill the denominator list with all the denominator digits (as many as needed for the 
terms).For each term, the first digit of the denominator is equal to last digit of the previous term. The second digit is equal
to the last digit of the previous term + 1 (so if 4, it's equal to five.), and finally the third digit is also equal to the 
previous term's last digit + 1. In this manner, we're able to have sequences that start with the last digit's number while at 
the same time increasing by one.
"""
for x in range(1,num_approx+1):
    denominator.append(denominator[-1])
    denominator.append(denominator[-1]+1)
    denominator.append(denominator[-1]+1)

#The next step is to divide this list into a list of lists, each sub-list containing three digits (for the denominator)
denominator1 = []
chunk_size = 3
for i in range(0, len(denominator), chunk_size):
    denominator1.append(denominator[i:i+chunk_size])

count1=0
count=1
#in this loop, we calculate each term individually, using the new list of lists, denominator1.
for i in range(0,num_approx-1):
    count+=1
    term=4/((denominator1[i][0])*(denominator1[i][1])*(denominator1[i][2]))
    #it's important that the second index remain stable between 0,1,2 or it will go out of range. The first index can increase
    #with the counter, as it traverses the denominator1 list through num_approx. We subtract one from it as the "3"
    #is considered the first term of pi.
    if count % 2 ==0:
        pi.append(term)
    else:
        pi.append(-term)
    #given that the terms alternate between positive and negative, we use the modular so that if the index is even, we append
    #a positive term, whilst if it's odd, we append a negative term.
pi_approximation=math.fsum(pi) #we then use fsum to add together all the terms (floats) appended in pi.
print(num_approx,"approximations of pi are equal to:",round(pi_approximation,4)) #finally we display the output to the user.
